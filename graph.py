from logging import getLogger

from enum import Enum

NodeState = Enum('NodeState', 'UNTOUCHED DEFENDED BURNING')

logger = getLogger("graph_printing")


class Graph(object):
    def __init__(self):
        self.nodes_number = 0
        self.nodes = dict()
        self.init_nodes = list()
        self.burning_nodes = list()
        super(Graph, self).__init__()

    def get_edges(self):
        edges = list()
        for node_id in self.nodes:
            for neighbor in self.nodes[node_id].get_neighbors():
                if (neighbor.id, node_id) not in edges:
                    edges.append((node_id, neighbor.id))
        return edges

    def get_burning_nodes(self):
        return self.burning_nodes

    def get_nodes(self):
        return self.nodes

    def get_init_nodes(self):
        return self.init_nodes

    @classmethod
    def from_file(cls, input_file):
        """ Generate graph from file format:
        n m
        1 4
        1 2
        2 3
        ...

        where:
            n - number of the vertices
            m - number of edges
        second line lists starting vertices
        the following lines determine edges
        this is exactly the format generated by the generate utility
        """

        new_instance = cls()
        with open(input_file, 'r') as f:
            new_instance.nodes_number, _ = map(int, f.readline().split())
            starting_nodes_ids = [int(s) for s in f.readline().split()]
            for node_id in xrange(new_instance.nodes_number):
                new_instance.nodes[node_id] = Node(node_id)
            for line in f:
                v1, v2 = map(int, line.split())
                new_instance.nodes[v1].add_neighbor(new_instance.nodes[v2])
            new_instance.init_nodes = [new_instance.nodes[node_id] for node_id in starting_nodes_ids]
        return new_instance

    def print_graph(self):
        """ For the time being a dumb method to help with debugging """
        for node in self.nodes.values():
            logger.info("Node {}: {}".format(node.id, node.state))

    def reset_state(self):
        for v in self.nodes.values():
            v.reset_state()
        self.burning_nodes = list()

    def set_init_nodes_on_fire(self):
        for node in self.init_nodes:
            self.set_node_as_burning(node)

    def set_node_as_burning(self, node):
        self.burning_nodes.append(self.nodes[node.id])
        node.set_as_burning()


class Node(object):
    def __init__(self, node_id, value=None):
        self.id = node_id
        self.neighbors = set()
        self.state = NodeState.UNTOUCHED
        self.value = value
        super(Node, self).__init__()

    def add_neighbor(self, node):
        self.neighbors.add(node)
        node.neighbors.add(self)

    def get_neighbors(self):
        return self.neighbors

    def print_node(self):
        """ Print the graph structure accessible from this node """
        logger.info("Node {}: {}".format(self.id, self.neighbors))

    def reset_state(self):
        self.state = NodeState.UNTOUCHED

    def set_as_burning(self):
        self.state = NodeState.BURNING

    def __eq__(self, other):
        return self.id == other.id

    def __str__(self):
        return "Node({})".format(self.id)

